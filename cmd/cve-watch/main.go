package main

import (
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/njohnstone2/cve-watch/internal/handlers"
	"github.com/njohnstone2/cve-watch/internal/nvd"
	"github.com/sirupsen/logrus"
	log "github.com/sirupsen/logrus"
	"github.com/slack-go/slack"
	"github.com/urfave/cli/v2"
)

const (
	timeFormat = "2006-01-02T15:04:05.000"
	baseUrl    = "https://services.nvd.nist.gov/rest/json/cves/2.0"
)

func main() {
	config := DefaultConfig()
	nvdConfig := nvd.DefaultConfig()

	configItems := []ConfigItem{
		&config,
		&nvdConfig,
	}
	var params []cli.Flag
	for _, p := range configItems {
		params = append(params, p.Parameters()...)
	}

	app := &cli.App{
		Name:  "cve-watch",
		Usage: "monitors the National Vulnerability Database (NVD) for new CVE's",
		Flags: params,
		Action: func(c *cli.Context) error {
			nvdConfig.IncludeFilters = c.StringSlice("include-filters")

			for _, c := range configItems {
				validationError := c.Validate()
				if validationError != nil {
					return validationError
				}
			}

			interrupt := make(chan os.Signal, 1)
			signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

			r := handlers.Router()
			srv := &http.Server{
				Addr:    fmt.Sprintf(":%d", config.HTTPPort),
				Handler: r,
			}

			shutdown := make(chan struct{}, 1)
			go func() {
				err := srv.ListenAndServe()
				if err != nil {
					shutdown <- struct{}{}
					log.Printf("%v", err)
				}
			}()
			log.Print("The service is ready to listen and serve.")

			interval, err := time.ParseDuration(fmt.Sprintf("%dm", config.IntervalMins))
			if err != nil {
				log.WithError(err).Error("failed_to_parse_poll_interval")
			}

			severities := strings.Split(nvdConfig.CveSeverities, ",")
			client := nvd.NewClient(nvdConfig, nvdConfig.IncludeFilters)
			log.WithFields(logrus.Fields{
				"filters":    nvdConfig.IncludeFilters,
				"severities": nvdConfig.CveSeverities,
			}).Debug("config_values")

			// Run the query every minute
			go func() {
				for {
					for _, s := range severities {
						err := fetchCves(config, *client, interval, s)
						if err != nil {
							log.WithError(err).Error("failed_to_fetch_cves")
						}
					}

					// Sleep for the defined interval before making the next request
					time.Sleep(interval)
				}
			}()

			select {
			case killSignal := <-interrupt:
				switch killSignal {
				case os.Interrupt:
					log.Print("Received SIGINT...")
				case syscall.SIGTERM:
					log.Print("Received SIGTERM...")
				}
			case <-shutdown:
				log.Printf("Received an error...")
			}

			log.Print("The service is shutting down...")
			srv.Shutdown(context.Background())

			return nil
		},
	}

	if err := app.Run(os.Args); err != nil {
		log.Fatal(err)
	}
}

func fetchCves(config Config, client nvd.NVDClient, interval time.Duration, severity string) error {
	// Set up the API endpoint URL
	now := time.Now()
	endtime := now.Format(timeFormat)
	starttime := now.Add(-interval).Format(timeFormat)
	url := fmt.Sprintf("%s/?pubStartDate=%s&pubEndDate=%s&cvssV3Severity=%s", baseUrl, starttime, endtime, severity)
	log.WithField("url", url).Info("Querying API")

	// Make the HTTP GET request
	response, err := client.Get(url)
	if err != nil {
		handlers.SetReadyz(false)
		return err
	}
	if response.StatusCode == http.StatusOK {
		handlers.SetReadyz(true)
	}

	// Read the response body
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return err
	}

	// Parse the JSON response
	var data nvd.APIResponse
	err = json.Unmarshal(body, &data)
	if err != nil {
		return err
	}

	// Process each CVE
	cves := client.FilterCVEs(data.Vulnerabilities)
	for _, cve := range cves {
		msg := buildMessage(cve)
		pErr := slackPost(config.SlackToken, config.SlackChannelId, msg)
		if pErr != nil {
			log.WithError(pErr).Error("failed_post_to_slack")
			return pErr
		}
	}

	if len(data.Vulnerabilities) == 0 {
		log.Info("No new CVEs found")
	}

	return nil
}

func slackPost(token, channelId string, msg slack.Message) error {
	api := slack.New(token)
	channelID, timestamp, err := api.PostMessage(
		channelId,
		slack.MsgOptionBlocks(msg.Blocks.BlockSet...),
		slack.MsgOptionAsUser(true),
	)
	if err != nil {
		return err
	}
	log.WithFields(log.Fields{
		"channel_id": channelID,
		"timestamp":  timestamp,
	}).Info("Message successfully sent to channel")

	return nil
}
