package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"time"

	log "github.com/sirupsen/logrus"
	"github.com/slack-go/slack"
)

const (
	timeFormat = "2006-01-02T15:04:05.000"
	baseUrl    = "https://services.nvd.nist.gov/rest/json/cves/2.0"
)

var (
	NVD_API_KEY      = os.Getenv("NVD_API_KEY")
	SLACK_TOKEN      = os.Getenv("SLACK_TOKEN")
	SLACK_CHANNEL_ID = os.Getenv("SLACK_CHANNEL_ID")
	LOG_LEVEL        = os.Getenv("LOG_LEVEL")
	INTERVAL_MINS    = os.Getenv("INTERVAL_MINS")
	SEVERITIES       = os.Getenv("SEVERITIES")
)

func main() {
	interval, err := time.ParseDuration(fmt.Sprintf("%sm", INTERVAL_MINS))
	if err != nil {
		log.WithError(err).Error("failed_to_parse_poll_interval")
	}

	severities := strings.Split(SEVERITIES, ",")
	client := &http.Client{}

	// Run the query every minute
	for {
		for _, s := range severities {
			err := fetchCves(*client, interval, s)
			if err != nil {
				log.WithError(err).Error("failed_to_fetch_cves")
			}
		}

		// Sleep for the defined interval before making the next request
		time.Sleep(interval)
	}
}

func fetchCves(client http.Client, interval time.Duration, severity string) error {
	// Set up the API endpoint URL
	now := time.Now()
	endtime := now.Format(timeFormat)
	starttime := now.Add(-interval).Format(timeFormat)
	url := fmt.Sprintf("%s/?pubStartDate=%s&pubEndDate=%s&cvssV3Severity=%s", baseUrl, starttime, endtime, severity)

	// Make the HTTP GET request
	req, _ := http.NewRequest("GET", url, nil)
	req.Header.Set("Accept", "application/json")
	req.Header.Set("apiKey", NVD_API_KEY)

	log.WithField("url", url).Info("Querying API")
	response, err := client.Do(req)
	if err != nil {
		return err
	}

	// Read the response body
	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		return err
	}

	// Parse the JSON response
	var data APIResponse
	err = json.Unmarshal(body, &data)
	if err != nil {
		return err
	}

	// Process each CVE
	for _, item := range data.Vulnerabilities {
		log.WithField("id", item.CVE.ID).Debug("processing_cve")
		msg := buildMessage(item.CVE)
		pErr := slackPost(SLACK_TOKEN, SLACK_CHANNEL_ID, msg)
		if pErr != nil {
			log.WithError(pErr).Error("failed_post_to_slack")
			os.Exit(1)
		}
	}

	if len(data.Vulnerabilities) == 0 {
		log.Info("No new CVEs found")
	}

	return nil
}

func slackPost(token, channelId string, msg slack.Message) error {
	api := slack.New(token)
	channelID, timestamp, err := api.PostMessage(
		channelId,
		slack.MsgOptionBlocks(msg.Blocks.BlockSet...),
		slack.MsgOptionAsUser(true),
	)
	if err != nil {
		return err
	}
	log.WithFields(log.Fields{
		"channel_id": channelID,
		"timestamp":  timestamp,
	}).Info("Message successfully sent to channel")

	return nil
}
