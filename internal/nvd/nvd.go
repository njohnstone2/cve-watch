package nvd

import (
	"net/http"
	"strings"

	"github.com/sirupsen/logrus"
	log "github.com/sirupsen/logrus"
)

type NVDClient struct {
	client      http.Client
	config      NVDConfig
	inclFilters []string
}

func NewClient(c NVDConfig, inclFilters []string) *NVDClient {
	return &NVDClient{
		config:      c,
		inclFilters: inclFilters,
	}
}

func (c *NVDClient) Get(url string) (resp *http.Response, err error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	return c.Do(req)

}

func (c *NVDClient) Do(req *http.Request) (*http.Response, error) {
	req.Header.Set("Accept", "application/json")
	req.Header.Add("apiKey", c.config.NvdApiKey)

	return c.client.Do(req)
}

func (n *NVDClient) FilterCVEs(v []Vulnerability) []CVE {
	cves := make([]CVE, 0)
	log.WithFields(logrus.Fields{
		"include": n.inclFilters,
	}).Debug("filters")

	for _, item := range v {
		log.WithField("id", item.CVE.ID).Debug("processing_cve")

		hasMatch := false
		for _, desc := range item.CVE.Descriptions {
			log.WithFields(logrus.Fields{
				"cve":  item.CVE.ID,
				"desc": desc,
			}).Debug("process_descriptions")

			// Skip processing filters if a match has already been found
			if hasMatch {
				continue
			}

			if len(n.inclFilters) == 0 {
				cves = append(cves, item.CVE)
				hasMatch = true
				continue
			}

			for _, filter := range n.inclFilters {
				normalisedFilter := strings.ToLower(filter)
				normalisedDescription := strings.ToLower(desc.Value)
				if strings.Contains(normalisedDescription, normalisedFilter) && !hasMatch {
					log.WithFields(logrus.Fields{
						"cve":    item.CVE.ID,
						"desc":   desc,
						"filter": filter,
					}).Info("description_match_found")
					cves = append(cves, item.CVE)
					hasMatch = true
				}
			}
		}
	}
	return cves
}
