package nvd

import (
	"net/http"
	"strings"

	log "github.com/sirupsen/logrus"
)

type NVDClient struct {
	client      http.Client
	config      NVDConfig
	inclFilters []string
	exclFilters []string
}

func NewClient(c NVDConfig, inclFilters, exclFilters []string) *NVDClient {
	return &NVDClient{
		config:      c,
		inclFilters: inclFilters,
		exclFilters: exclFilters,
	}
}

func (c *NVDClient) Get(url string) (resp *http.Response, err error) {
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	return c.Do(req)

}

func (c *NVDClient) Do(req *http.Request) (*http.Response, error) {
	req.Header.Set("Accept", "application/json")
	req.Header.Add("apiKey", c.config.NvdApiKey)

	return c.client.Do(req)
}

func (n *NVDClient) FilterCVEs(v []Vulnerability) []CVE {
	cves := make([]CVE, 0)
	log.WithField("count", len(v)).Info("Total CVEs")

	for _, item := range v {
		log.WithFields(log.Fields{
			"id":              item.CVE.ID,
			"include_filters": len(n.inclFilters),
			"exclude_filters": len(n.exclFilters),
		}).Debug("processing_cve")

		hasMatch := false
		exclude := false
		for _, desc := range item.CVE.Descriptions {
			log.WithFields(log.Fields{
				"cve":  item.CVE.ID,
				"desc": desc,
			}).Debug("process_descriptions")

			// Skip processing filters if a match has already been found
			if hasMatch {
				continue
			}

			for _, filter := range n.exclFilters {
				normalisedFilter := strings.ToLower(filter)
				normalisedDescription := strings.ToLower(desc.Value)
				if strings.Contains(normalisedDescription, normalisedFilter) {
					log.WithFields(log.Fields{
						"cve":            item.CVE.ID,
						"desc":           desc,
						"exclude_filter": filter,
					}).Debug("filter_exclude_description_match_found")
					hasMatch = false
					exclude = true
					continue
				}
			}

			// Add CVE if no include filters are defined
			if len(n.inclFilters) == 0 && !exclude {
				cves = append(cves, item.CVE)
				hasMatch = true
				continue
			}

			if !exclude {
				for _, filter := range n.inclFilters {
					normalisedFilter := strings.ToLower(filter)
					normalisedDescription := strings.ToLower(desc.Value)
					if strings.Contains(normalisedDescription, normalisedFilter) && !hasMatch {
						log.WithFields(log.Fields{
							"cve":            item.CVE.ID,
							"desc":           desc,
							"include_filter": filter,
						}).Info("filter_include_description_match_found")
						cves = append(cves, item.CVE)
						hasMatch = true
					}
				}
			}
		}
	}
	return cves
}
